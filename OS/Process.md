## 정의
프로세스: 컴퓨터에서 연속적으로 실행되고 있는 컴퓨터 프로그램   
> 어떤 프로그램을 실행할 때 운영체제는 이 프로그램을 실행하기 위해 필요한 메모리 공간을 할당하고, 이 할당된 메모리 공간을 가지고 `독립적`으로 실행되는 것


**[프로세스의 특징]**
- 각자 독립된 메모리 영역(코드, 데이터, 스택)을 가짐
- 다른 프로세스와는 독립적으로 작동

## 알아야 하는 이유
> 컴퓨터 시스템의 자원 관리, 효율적인 작업 실행, 운영체제의 멀티태스킹과 프로그램 동작 원리를 깊게 이해하기 위해서

### 1. 메모리 공간의 독립성 관련 문제 상황
위 상황은 MSA 또는 SSR에서 문제 발생 가능하다.   
MSA에서 동일한 데이터를 다루어야 할 때, 각 서비스는 독립된 메모리 공간을 가지므로, 데이터 일관성을 유지하기 위해 복잡한 동기화 및 통신 로직이 필요함

IPC 설정이 잘못되어 데이터가 제대로 공유되지 않는 경우, 일관성 없는 데이터로 인해 사용자에게 잘못된 정보가 표시되거나 시스템의 신뢰성이 떨어질 수 있음.


### 2. 자원 누수 방지 관련 문제 상황
백엔드 서버가 DB 연결이나 네트워크 소켓 등을 적절히 관리하지 않으면 자원 누수 발생 가능

이런 누수는 매모리 & CPU 사용률을 지속적으로 증가  
➡️ 서버의 응답이 길어짐   ➡️ 심하면 서버 다운까지 발생 가능  
따라서 프로세스의 생명주기를 정확히 이해하고 관리하는 것이 중요

### 3. 동시성 문제 해결 관련 문제 상황
동시에 많은 요청을 처리해야 하는 웹 어플리케이션에서 동시성 관리는 필수적
- 동시성 관리: 다수의 작업이 동시에 실행될 때 발생할 수 있는 충돌을 방지하고, 자원을 효율적으로 활용하도록 도움
  - 멀티스레드 환경에서 특히 중요
  - 프로그램의 성능을 최적화, 응답성을 향상시키는데 기여

ex. 동시 접속을 처리할 때 각 요청을 별도의 스레드나 프로세스로 처리하지 않으면 요청이 서로 대기 상태에 빠져 전반적인 응답 시간 저하 가능


## 동작 방식
로딩 -> 실행 -> 대기 -> 종료  
1. 운영체제는 프로그램을 메모리에 `로드`하고
2. CPU 할당을 통해 명령어를 `실행`한 후
3. 입출력이나 다른 이벤트 `대기` 상태에 들어가고
4. 작업이 완료되면 자원을 해제하며 `종료`

|순서|항목|내용|
|---|---|---|
|1|**로드**|OS는 사용자가 실행은 요청한 프로그램을 메모리에 로드함  |
|2|**실행**|프로그램이 메모리에 로드되면, CPU는 프로그램의 명령어를 차례대로 실행하기 시작함. 이때 프로그램은 데이터를 처리하고, 계산을 수행하는 등의 작업을 진행함|
|3|**대기**|프로그램 실행 중에는 파일 입출력, 네트워크 통신과 같은 외부 이벤트가 발생할 수 있음. 이때 프로그램은 해당 이벤트가 완료될 때까지 대기 상태에 들어갈 수 있음|
|4|**종료**|프로그램의 모든 작업이 완료되고, 더 이상 실행할 명령어가 없으면, 운영 체제는 프로그램에 할당된 자원을 해제하고 프로세스를 종료함|


`프로그램`이 실제로 움직이는 프로그램이 되면 `프로세스`라 함

## 프로세스의 구조
![Image](https://github.com/user-attachments/assets/c9b15382-080c-431f-93c5-7798d7fd0098)
- Text Section: 실행 가능한 코드를 저장하는 공간
- Data Section: 전역 변수/초기화된 데이터를 저장하는 공간
- Heap Section: 프로그램 실행동안 동적으로 할당되는 변수가 저장되는 공간
- Stack Section: 함수가 실행되는 동안 지역변수가 저장되는 임시 공간 (대표적으로 함수 매개변수, 리턴 주소, 지역 변수 등이 포함)

```c
#include <stdio.h>
#include <stdlib.h>

int x;
int y = 15;

int main(int argc, char *argv[])
{
    int *values;
    int i;

    values = (int *) malloc(sizeof(int)*5);

    for(i=0; i<5; i++)
    {
        values[i] = i;
    }

    for(i=0; i<5; i++)
    {
        printf("%d ", values[i]);
    }
    printf("\n");
    return 0;
}

```
> - Text Section: 코드 텍스트
> - Data Section: `x`(uninitialized data), `y`(initialized data)
> - Heap Section: `(int *) malloc(sizeof(int)*5)`
> - Stack Section: `main`, `value`, `i`

## 프로세스의 상태
운영체제는 새로운 프로세스를 생성할 때, 그 프로세스에 대한 프로세스 제어 블록(PCB)를 생성하고 그 프로세스를 비수행 상태로 시스템 내에 초기화

### 2-상태 프로세스 모델
![Image](https://github.com/user-attachments/assets/a3ebe601-9248-413b-9b74-f7d0314d1c6c)
- 수행
- 비수행
  
### 3-상태 프로세스 모델
![Image](https://github.com/user-attachments/assets/201aa4e2-5b68-4f1c-8165-b4854b0b592d)
- Running(실행): 프로세스가 처리기 상에서 실행
- Ready(준비): 어떤 이유로 OS가 특정 순간에 이 프로세스를 실행하지 않음
- Blocked(블록) = Sleep = 수면
  - 프로세스가 특정 작업을 수행
  - 프로세스가 디스크에 대한 I/O 요청을 시작하면 블럭 상태가 되고, 다른 프로세스가 처리기 상에서 실행될 수 있음

### 5-상태 프로세스 모델
![Image](https://github.com/user-attachments/assets/7e4523d5-0bbd-4c57-bb19-7e4f4e822339)
- Swapping
  - Swap-in: swap -> 주기억장치
  - Swap-out: 주기억장치 -> swap
  
### 9-상태 프로세스 모델
![Image](https://github.com/user-attachments/assets/35a9707b-b143-4b9e-89fa-cb6da08159b2)

## 프로세스 제어 블록 (PCB)
![Image](https://github.com/user-attachments/assets/764e5017-768b-4bed-a67b-4736d68c3e24)  
: 각 프로세스의 정보를 담고 있는 struct형 자료구조

수행 프로세스를 인터럽트한 후 나중에 그 인터럽트가 발생되지 않은 것처럼 프로세스 수행을 재개할 수 있도록 충분한 정보를
유지하는 것

### 문맥 (Content)
- system context
- memory context
- register context

### Context Switching
1. Save the Old Context  
어떤 프로세스가 인터럽트 될 때 프로그램 카운터 및 처리기 레지스터들(문맥 데이터) 의 현재 값이 해당 프로세스 제어블록의 적절한 필드에 저장되고
2. Execution of the New Content  
그 프로세스의 상태가 이후 설명될 블록 또는 준비 등과 같은 값으로 변경. OS는 다른 프로세스 선택하여 수행 상태로 만들고 그 프로세스의 프로그램 카운터와 문맥 데이터를 처리기 레지스터로 적재하여 새로운 프로세스를 수행

## 프로세스 스케줄링
### 스케줄링
- 프로세스가 생성되어 실행될 때 필요한 시스템의 여러 자원을 해당 프로세스에게 할당하는 작업
- 대기 시간은 최소화하고 최대한 공평하게 처리하는 것을 목적으로 함

### 스케줄링의 종류
- preemptive scheduling (선점)
- non-preemptive schedulig (비선점)

### 선점 스케줄링
: 하나의 프로세스가 CPU를 차지하고 있을 때, 우선순위가 높은 다른 프로세스가 현재 프로세스를 중단시키고 CPU를 점유하는 스케줄링 방식  

**1. Round Robin**
- 프로세스마다 같은 크기의 TQ(time quantum) 할당
- 프로세스가 할당된 시간 내에 처리 못하면 큐 리스트의 끝으로 보내짐, CPU는 대기 중인 다음 프로세스로 넘어감
- 균등한 CPU 시간, 시분할 시스템

**2. SRT(Shortest Remaining Time First)**
- 가장 짧은 시간이 소요되는 프로세스 먼저 수행
- 남은 시간이 더 짧은 프로세스가 ready 큐에 있으면 해당 프로세스가 선점함

**3. MLQ (Multi Level Queue)** 
- 여러 개의 큐로 나누어지며, 상위 큐로 갈 수록 선점

**4. MLFQ (Multi Level Feedback Queue)**
- 새로운 프로세스는 높은 우선순위를 가지지만 프로세스의 실행 시간이 길어질 수록 점점 낮은 우선순위 큐로 이동하며, (이 때, 우선 순위가 낮을 수록 시간할당량을 크게 줌으로써 보완 가능) 마지막 단계에서 FCFS 방식을 적용

### [ 비선점 스케줄링 ]
: 이미 할당된 CPU를 다른 프로세스가 강제로 빼앗아 사용할 수 없는 스케줄링 기법, 프로세스가 CPU를 할당 받으면 해당 프로세스가 완료될 때까지 CPU를 사용하지 않음

**1. FCFS (First Come First Serve/Scheduling)**  
- 먼저 도착하는 순서대로 CPU 할당

**2. SJF (Shortest Job First)**  
- 프로세스가 도착하는 시점에 따라 그 당시 가장 작은 서비스 기간을 갖는 프로세스가 종료 시 까지 차지

**3. HRN (Highest Response Ratio Next)**
- 대기 중인 프로세스 중 현재 Response Ratio가 가장 높은 것을 선택
- (Response Ratio = (대기시간 + 서비스시간) / 서비스시간)
- 대기시간이 긴 프로세스일 경우 우선순위가 높아짐