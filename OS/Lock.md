`date: 25.02.10`
# 1️⃣ 락 (Lock)
: 하나의 스레드나 프로세스가 자원을 점유할 경우 다른 스레드 / 프로세스가 해당 자원에 접근하지 못하도록 제어하는 기법

- 데이터 무결성 손실, 데이터 경합, 데드락, 원자성 보장과 같은 문제를 방지하기 위한 동기화 매커니즘
- 원자성을 통해 작업 단위가 안전하게 수행되도록 보장


<aside>

    💡 원자성
    : 작업 단위가 더 이상 나뉠 수 없는 하나의 원자적 실행 단위로 동작함을 보장하는 개념  
    ➡️ 작업이 모두 실행되거나, 전혀 실행되지 않는 상태
</aside>


## 동작 방식
- lock은 thread safety를 지키는 방법 중 하나인 mutual exclusion의 특성을 가지고 있음
- 공유 자원에 대해서 하나의 자원만 접근하도록 함
- 그래서 lock을 획득한 스레드만이 공유 자원에 접근할 수 있게 하는 방법
  - lock 획득? 락을 획득한 스레드가 데이터를 제어할 수 있는 권한을 얻었다..

# 2️⃣ 락의 종류
## 1. 스핀 락 (Spin Lock)
: 한 Thread가 임계 영역을 점유하고 있을 때, 다른 Thread가 락이 해제되기를 기다리며 "**계속해서 반복적으로 락 상태를 확인하는**" 방식의 락
- busy-waiting 방식
- 락 점유 시간 제한
- 다중 코어에 적합

**장점**
|항목|설명|
|--|--|
|빠른 락 점유 해제|락을 기다리면서 대기 상태로 전환하지 않고, 반복적으로 확인하므로 락이 빠르게 해제될 경우 즉시 점유가 가능|
|컨텍스트 스위칭 없음|락 대기 중 컨텍스트 스위칭(스레드 스케줄링)이 발생하지 않으므로 락이 짧은 시간 내에 해제될 경우 오버헤드가 적음|
|간단한 구현|스핀락은 구현이 비교적 간단하며, 하드웨어나 운영체제의 지원이 필요없는 경우도 많음|

**단점**
|항목|설명|
|--|--|
|CPU 사용률 증가|락이 해제될 때까지 반복 확인을 하기 때문에 CPU 자원을 계속 소비|
|비효율적인 대기|락 해제가 오래 걸릴 경우 busy-waiting으로 인한 비효율 발생, 다른 프로세스/스레드의 CPU 자원 사용을 방해 가능|
|단일 CPU환경 부적합|단일 CPU 환경에서는 락을 점유한 스레드와 대기 중인 스레드가 동시에 실행될 수 없기 때문에 busy-waiting 자체가 비효율적|

## 2. 낙관적 락 (Optimistic Lock)
: 데이터 충돌이 드물다는 가정 하에 락 없이 작업을 수행하고, 충돌이 발생하면 롤백을 통해 해결하는 방식 (락 사용하지 않음)
- 충돌 감지 방식
- 낙관적인 접근 방식
- 주로 읽기 중심 시스템에서 사용
  
**장점**
| **항목** | **설명** |
| --- | --- |
| 데이터 경합 없는 환경에서 효율적 | 락을 사용하지 않으므로, 충돌이 거의 발생하지 않는 환경에서는 성능이 매우 뛰어납니다. |
| 낮은 오버헤드 | 초기에는 별도의 락을 획득하지 않고 작업을 수행하므로, 락 관리에 따른 오버헤드가 거의 없습니다. |
| 병렬 처리 강화 | 여러 스레드가 동시에 공유 자원에 접근할 수 있으므로, 데이터 경합이 적은 경우 병렬 처리 성능이 극대화됩니다. |

**단점**
| **항목** | **설명** |
| --- | --- |
| 롤백 비용 발생 | 데이터 충돌이 발생하면 변경 사항을 롤백하고 재시도해야 하므로 롤백 비용이 발생할 수 있습니다. |
| 충돌 시 성능 저하 | 데이터 경합이 자주 발생하면 충돌을 처리하는 데 시간이 소요되며, 성능이 급격히 저하될 수 있습니다. |
| 복잡한 구현 | 충돌 감지 및 롤백 메커니즘을 구현해야 하므로, 설계 및 구현이 비교적 복잡합니다. |


## 3. Mutex
: 특정 자원을 여러 프로세스나 스레드가 동시에 접근하지 못하도록 하여, 자원에 대한 동시 접근으로 인한 문제를 방지하는 매커니즘 (-> `Binary Semaphore`, **한 번에 하나의 스레드만 자원에 접근**할 수 있도록 제한)

<aside>

    💡 뮤텍스와 조건 변수 (Condition Variable)
    - 조건 변수
    : 스레드가 특정 조건이 충족될 때까지 대기하거나, 다른 스레드가 신호를 보내 대기 중인 스레드를 깨워 실행을 재개하도록 하는 동기화 매커니즘
        - 일반적으로 뮤렉스 락과 함께 동작
        - 스레드가 불필요하게 CPU를 점유하지 않고 조건이 충족될 때만 깨어나도록 설계
        - 생산자-소비자 문제와 같은 동기화 문제를 해결하는데 효과적

</aside>


**장점**
| **항목** | **설명** |
| --- | --- |
| 데이터 보호 | **한 번에 하나의 스레드**만 자원을 사용하도록 제한해, 데이터 무결성을 보장합니다. |
| 직관적인 동작 | 스레드 간 자원 보호의 목적을 명확히 하며, 동기화 문제가 발생할 가능성을 줄입니다. |
| 범용성 | 운영체제에서 기본적으로 제공되며, 대부분의 동기화 문제에 쉽게 적용할 수 있습니다. |

**단점**
| **항목** | **설명** |
| --- | --- |
| 컨텍스트 스위칭 오버헤드 | 락 대기 중 대기 상태로 전환되며, 컨텍스트 스위칭으로 인한 오버헤드가 발생할 수 있습니다. |
| 데드락 위험 | 스레드가 락을 해제하지 못하거나 여러 락을 잘못된 순서로 요청하면 데드락 상황이 발생할 수 있습니다. |
| 병렬 처리 제한 | 한 번에 하나의 스레드만 자원을 사용할 수 있으므로 병렬 처리가 제한됩니다. |


## 4. Read-Write Lock
: 다중 스레드 환경에서 읽기(Reader) 작업과 쓰기(Writer) 작업을 구분하여 락을 관리하는 동기화 매커니즘
- read: 여러 reader는 동시에 자원 접근 가능
- write: writer는 자원을 독점적으로 사용해야 함


**장점**
| **항목** | **설명** |
| --- | --- |
| 높은 동시성 | 다수의 Reader가 동시에 자원에 접근할 수 있어, 읽기 중심의 작업에서 성능을 향상시킵니다. |
| 데이터 무결성 보장 | Writer가 자원을 독점하여 수정 작업을 수행하므로, 데이터의 일관성을 보장합니다. |
| 효율적인 리소스 활용 | 읽기 작업이 많고 쓰기 작업이 적은 환경에서 CPU와 메모리 자원을 효율적으로 활용할 수 있습니다. |

**단점**

| **항목** | **설명** |
| --- | --- |
| Writer 기아 현상 | 많은 Reader가 연속적으로 자원을 점유할 경우, Writer가 락을 획득하지 못해 대기 시간이 길어질 수 있습니다. |
| 복잡한 구현 | Reader와 Writer의 락 상태를 구분하여 관리해야 하므로, 단순한 뮤텍스보다 구현이 복잡합니다. |
| 데드락 가능성 | Reader와 Writer 간의 잘못된 락 요청 순서로 인해 데드락이 발생할 수 있습니다. |