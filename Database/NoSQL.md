# NoSQL
: SQL만을 사용하지 않는 여러 유형의 데이터베이스 (RDBMS 말고)
- 대용량의 데이터를 효과적으로 관리
- 다양한 형태의 데이터를 유연하게 처리할 수 있음
- 수평적인 관리

|이유|설명|
|-|-|
|데이터의 다양성|
|**대규모 데이터 처리**|
|수평적 확장성|
유연한 설계 및 개발 속도|

# 데이터 구조
## 1️⃣ 키-값 저장소
: 각 키에 하나의 값이 매핑되는 가장 단순한 형태의 데이터 저장 방식
- 인메모리 데이터베이스 (디스크가 아닌 메모리에 저장 -> 읽/쓰 굉장히 빠름)
- ex. Redis

<aside>

    - 쓰기: 키를 해싱하여 데이터 저장 위치 결정.
    - 읽기: 키를 입력받아 데이터를 검색.
    - 샤딩: 해시 함수를 사용해 데이터를 여러 노드에 분산 저장.
</aside>


|장점|단점|
|-|-|
|빠른 읽기/쓰기 속도|복잡한 데이터 관계 처리 어려움|
|간단한 데이터 구조|

## 2️⃣ 문서 지향 데이터베이스
```json
{
    "user_id": "12345",
    "name": "Alice",
    "age": 25,
    "email": "alice@example.com"
}
```
: 반정형 데이터(JSON, XML)과 같은 문서 형식을 사용하여 데이터 저장
- 각자의 도큐먼트가 고유한 ID를 가지고 컬렉션으로 관리
- ex. MongoDB (개발 편의성, 유연한 확장성)
<aside>

    - 쓰기: 고유 ID로 문서를 저장
    - 읽기: ID 또는 특정 조건(필드값)을 기준으로 문서를 검색
    - 인덱스: 특정 필드에 대해 인덱스를 생성하여 조회 속도를 최적화
</aside>


|장점|단점|
|-|-|
|유연한 스키마와 복잡한 데이터 모델링 가능|데이터 간 관계성이 약함|


## 3️⃣ 컬럼 기반 데이터베이스
```less
RowKey: User_12345
Columns: name: Alice, age: 25, email: alice@example.com
```
: 컬럼(열) 단위로 데이터를 저장하고 관리, 대량의 데이터를 빠르게 조회, 분석 가능
- ex. Cassandra
- Row-Oriented vs Column-Oriented
  - Row-Oriented
  - Column-Oriented

<aside>

    - 쓰기: RowKey와 Column 기준으로 데이터를 저장
    - 읽기: 특정 RowKey 또는 Column 기반으로 데이터 검색
    - 샤딩: RowKey를 기준으로 데이터 분산
</aside>

|장점|단점|
|-|-|
|대규모 데이터 분석과 빠른 처리 가능(쓰기 작업에 좋음)|단순 조회(SELECT *)의 성능 저하|


## 4️⃣ 그래프 데이터베이스
```neo4j
Node: User (Alice)
Edbe: "Friend of"
Node: User (Bob)
```
: 데이터를 노드와 엣지로 표현하여, 객체 간의 관계를 중심으로 데이터를 저장하고 조회 
- ex. Neo4j

<aside>

    - 쓰기: 데이터는 노드(객체정보)와 간선(관계정보)으로 저장 -> Key-Value쌍으로 저장 가능
    - 읽기: 노드와 관계를 탐색
    - 인덱스: 노드 및 간선에 대한 인덱스를 생성하여 탐색 속도 향상
</aside>

|장점|단점|
|-|-|
|복잡한 데이터 관계를 효율적으로 탐색 가능|대규모 데이터를 처리할 때 성능 저하 가능|

<br>

---

## Eventual Consistency
: 분산 시스템에서 중요한 데이터 일관성 모델 중 하나

NoSQL은 대규모 처리와 수평적 확장을 지원하기 위해 실시간 일관성을 포기, 일정 시간이 지나면 데이터 일관성이 보장되는 Eventual Consistency 모델 채택
➡️ 데이터 무결성 직접 관리, 이를 위해 낙관성 동시성 제어(OCC) 같은 기법 사용

### OCC
: 낙관적 동시성 제어. DB 시스템에서 동시에 여러 트랜젝션이 데이터를 조작할 때 충돌을 관리하는 방식 중 하나
- 트랜잭션을 시작할 때 충돌 가능성을 점검하지 않고, 트랜잭션이 커밋되는 시점에서만 데이터 충돌을 검사함
- 충돌이 감지되면 트랜잭션을 롤백

### PCC
: 비관적 동시성 제어. 요청마다 충돌을 예상하고 LOCK을 거는 것
- 하나의 트랜잭션에서 데이터를 읽는 시점에 Lock 을 걸고, 조회 또는 갱신 처리가 완료될 때 까지 유지
- 테이블단위 혹은 Row 단위로도 Lock을 걸 수 있음
  - 범주에 따라 S-Lock(Shared Lock) 과 x-lock(Exclusive Lock)

**[ PCC Lock 의 종류 ]**
- Shared Lock: 공유 잠금. 잠금한 트랜잭션은 읽기만 가능하며, 다른 트랜잭션들도 읽기가 가능하다.
- Exclusive Lock: 전용 잠금. 잠금한 트랜잭션을 읽기 및 쓰기가 가능하나, 다른 트랜잭션은 읽기, 쓰기 모두 할 수 없다.

## CAP 이론 (CAP Theory)
`Consistency`: 모든 사용자가 데이터베이스의 최신 상태를 동일하게 볼 수 있어야  
`Availability`: 시스템의 일부가 고장나더라도 데이터베이스 전체의 서비스가 계속 유지되어야   
`Partition Tolerance`: 네트워크 오류가 발생해도 시스템이 계속 작동할 수 있어야  

➡️ 3가지를 모두 만족시킬 수 없다 (2가지만 선택하고, 1가지는 타협)
- 대부분의 NoSQL 시스템은 가용성 + 분할 허용 오차 허용 / 일관성: 사용자의 어플리케이션 레벨에서 관리