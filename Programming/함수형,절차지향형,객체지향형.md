`25.02.21`
<aside>

    💡 프로그래밍 패러다임?  
    : 간단하게 말하면 프로그래밍 스타일!  
    ➡️ 코드 구조, 유지보수성, 확장성 등에 영향을 미침

</aside>

# 🍀 절차적 프로그래밍
> 순차적인 실행 흐름 강조  

: 가장 전통적인 프로그래밍 패러다임  
프로그램을 **순차적**으로 실행되는 명령어 집합과 함수(또는 서브루틴)들의 조합으로 구성  
➡️ 프로그램의 흐름을 명확하게 기술, 문제를 단계별로 해결하는데 초점을 맞춤
- Procedure(프로시저)를 이용하여 작성하는 프로그래밍 스타일
  - routine, subroutine, method, function ...

## 절차적 프로그래밍의 주요 특징
- 순차적 실행  
: 프로그램은 위 -> 아래로, 또는 지정된 흐름에 따라 순차적으로 실행됨. 각 단계가 명확한 순서를 가지며, 조건문 or 반복문을 통해 분기와 반복을 제어함

- 함수와 서브루틴  
: 코드의 재사용과 모듈화를 위해 기능별로 함수 정의. 각 함수는 특정 작업을 수행, 필요에 따라 호출됨 

- 데이터와 변수
: 데이터를 저장하는 변수는 전역 변수 또는 지역 변수로 구분되며, 함수 간에 데이터를 주고받는 방식으로 프로그램이 동작

## 절차적 프로그래밍의 장단점
|장점|단점|
|--|--|
|단순하고 직관적|확장성의 한계|
|빠른 프로토타이핑|코드의 재사용성과 유지보수성 제한|

## 절차적 프로그래밍 예시
대표적인 절차적 언어: C, Pascal, Fortran ...

```c
#include <stdio.h>
// 두 수의 합을 구하는 함수
int add(int a, int b) {
    return a + b;
}

int main() {
    int num1, num2, sum;

    // 사용자로부터 두 개의 숫자 입력 받기
    printf("첫 번째 숫자를 입력하세요: ");
    scanf("%d", &num1);
    printf("두 번째 숫자를 입력하세요: ");
    scanf("%d", &num2);

    // 함수 호출을 통해 합 계산
    sum = add(num1, num2);

    // 결과 출력
    printf("두 수의 합은 %d 입니다.\n", sum);

    return 0;
}
```
`main()`: 프로그램의 시작점이며, 순차적으로 사용자 입력, 함수 호출, 결과 출력의 과정을 거침.
`add()`: 입력된 두 수의 합을 계산하여 반환

<br>

# 🍀 객체지향 프로그래밍
> 데이터를 객체 단위로 묶어 모듈화 강화

## 객체지향 프로그래밍의 기본 개념
- 객체: 상태(속성, attributes)와 행동(메서드, methods)를 포함하는 독립적인 단위  
현실 세계의 개념을 소프트웨어적으로 모델링하여 직관적인 코드 작성이 가능함
- 클래스: 객체를 생성하기 위한 템플릿, 객체의 속성과 기능 정의
  
[OOP의 원칙]
- 캡슐화
- 상속
- 다형성

## 객체지향 프로그래밍의 주요 특징
- 현실 세계 모델링  
  : 실제 세계의 사물과 개념을 객체라는 단위로 추상화하여, 문제 영역을 보다 직관적으로 표현
- 모듈화  
  : 기능별로 클래스를 분리함으로써, 프로그램을 여러 개의 독립적인 모듈로 구성하여 유지보수와 확장이 용이
- 재사용성  
  : 상속과 다형성을 통해 기존 코드를 재사용하고, 새로운 기능을 확장할 수 있어 개발 효율이 높음

## 객체지향 프로그래밍의 장단점
|장점|단점|
|-|-|
|유지보수 용이|초기 설계의 복잡성|
|확장성|성능 오버헤드|
|코드 재사용|

## 예시
대표적인 언어: Java, Python, C++...
```python
# 클래스 정의: Person
class Person:
    def __init__(self, name, age):
        self.name = name  # 객체의 상태
        self.age = age

    # 객체의 행동을 정의하는 메소드
    def introduce(self):
        print(f"안녕하세요, 저는 {self.name}이고, {self.age}살입니다.")

# 객체 생성
person1 = Person("Alice", 30)
person2 = Person("Bob", 25)

# 메소드 호출
person1.introduce()  # 출력: 안녕하세요, 저는 Alice이고, 30살입니다.
person2.introduce()  # 출력: 안녕하세요, 저는 Bob이고, 25살입니다.
```
# 함수형 프로그래밍
: 상태 변화(부수 효과)를 최소화하고 순수 함수를 조합하여 예측 가능한 코드 작성 

* 부수 효과: 외부의 상태를 변경하는 것
* 순수 함수: 부수효과가 없는 함수. 즉, 어떤 함수에 동일한 인자를 주었을 때 항상 같은 값을 리턴하는 함수

## 함수형 프로그래밍의 특징
- 순수성과 부수 효과 최소화  
: 코드의 상태 변화와 외부 의존성을 줄임으로써, 함수의 동작을 쉽게 예측하고 테스트할 수 있음

- 불변성  
: 데이터 변경 대신 새로운 데이터를 생성하여, 프로그램의 안정성을 높임


- 함수의 조합과 재사용  
: 작은 단위의 순수 함수를 조합하여 복잡한 로직을 구성할 수 있으며, 모듈성과 재사용성이 좋음

- 병렬 처리에 유리  
: 불변성과 순수 함수 덕분에 상태 공유 없이 병렬 처리 및 비동기 작업을 구현하기에 적합

## 함수형 프로그래밍의 장단점
|장점|단점|
|-|-|
|디버깅과 테스트 용이|성능상의 오버헤드|
|코드의 예측 가능성|학습곡선|

## 함수형 프로그래밍의 예시
대표적인 언어: JavaScript, Python, Haskell...
```javascript
// 순수 함수: 입력값만으로 결과 결정, 외부 상태 변경 없음
const add = (a, b) => a + b;

// 부수 효과가 있는 함수 (Side Effect)
let count = 0;
const increase = () => count++;  // 전역 변수 count 변경 (부수 효과 발생)

// 고차 함수: 함수를 인자로 받거나 반환하는 함수
const applyOperation = (a, b, operation) => operation(a, b);

console.log(applyOperation(5, 3, add));  // 출력: 8

// 불변성을 위한 예: 배열의 map 함수 사용
const numbers = [1, 2, 3, 4];
const doubled = numbers.map(num => num * 2);
console.log(doubled);  // 출력: [2, 4, 6, 8]
```